import jinja2
import json
import os
import subprocess

import cclib
# For atomic number -> atomic symbol, and num valence electrons
from mendeleev import element
import openchemistry as oc


def run_calculation(geometry_file, output_file, params, scratch_dir):
    # Read in the geometry from the geometry file
    # This container expects the geometry file to be in .xyz format
    with open(geometry_file) as f:
        xyz_data = f.read()

    atomic_symbols, coords = extract_xyz(xyz_data)

    # Get the min/max values of each dimension for the atomic positions
    ranges = get_molecule_ranges(coords)

    # Make a unit cell big enough to simulate a vacuum.
    # Add a 10 angstrom vacuum on each side of the molecule.
    old_center = [(x[0] + x[1]) / 2.0 for x in ranges]
    lengths = [x[1] - x[0] for x in ranges]

    # Add a 10 angstrom vacuum to each length, and center the molecule
    lengths = [x + 10 for x in lengths]
    new_center = [x / 2 for x in lengths]
    translation = [new_center[i] - old_center[i] for i in range(len(lengths))]

    # Translate the coords to the center
    for i, coord in enumerate(coords):
        coords[i] = [c + t for c, t in zip(coord, translation)]

    # Set up input
    project = os.path.splitext(os.path.basename(geometry_file))[0]
    kinds = generate_kinds(atomic_symbols)
    cell = generate_cell(lengths)
    cp2k_coords = generate_coords(atomic_symbols, coords)

    # Read the input parameters
    task = params.get('task', 'energy')
    if task == 'energy':
        run_type = 'ENERGY'
    elif task == 'optimize':
        run_type = 'GEO_OPT'
    else:
        raise Exception('Invalid task: ' + str(task))

    context = {
        'project': project,
        'run_type': run_type,
        'kinds': kinds,
        'cell': cell,
        'coords': cp2k_coords
    }

    # Combine the input parameters and geometry into a concrete input file
    # that can be executed by the simulation code
    template_path = os.path.dirname(__file__)
    jinja2_env = jinja2.Environment(loader=jinja2.FileSystemLoader(template_path),
                                    trim_blocks=True)

    os.makedirs(scratch_dir, exist_ok=True)
    os.chdir(scratch_dir)
    raw_input_file = os.path.join(scratch_dir, 'raw.in')
    raw_output_file = os.path.join(scratch_dir, 'raw.out')

    with open(raw_input_file, 'wb') as f:
        jinja2_env.get_template('cp2k.in.j2').stream(**context).dump(f, encoding='utf8')

    # Execute the code and write to output
    subprocess.run(['/usr/bin/cp2k', '-i', raw_input_file,
                    '-o', raw_output_file])

    # Convert the raw output file generated by the code execution, into the
    # output format declared in the container description (cjson)
    cjson = oc.Cp2kReader(raw_output_file).read()

    # Save the calculation parameters in the cjson output for future reference
    cjson['inputParameters'] = params

    if task == 'energy' and 'atoms' not in cjson:
        # Set the original xyz positions back on the cjson
        data = cclib.io.ccread(geometry_file)
        input_cjson = json.loads(cclib.ccwrite(data, outputtype='cjson',))
        cjson['atoms'] = input_cjson['atoms']

    with open(output_file, 'w') as f:
        json.dump(cjson, f)


def extract_xyz(xyz_data):
    # Extract atomic nums and coords from xyz data
    # remove the first two lines in the xyz file
    # (i.e. number of atom and optional comment)
    xyz_data = xyz_data.split('\n')[2:]

    # Extract the atomic nums and the coords
    atomic_symbols = []
    coords = []
    for line in xyz_data:
        line = line.strip()
        if not line:
            continue

        vals = line.split()[:4]

        if vals[0].isdigit():
            num = int(vals[0])
            atomic_symbols.append(element(num).symbol)
        else:
            atomic_symbols.append(vals[0])

        coords.append([float(x) for x in vals[1:]])

    return atomic_symbols, coords


def get_molecule_ranges(coords):
    ranges = None
    for coord in coords:
        if ranges is None:
            ranges = [[x, x] for x in coord]
            continue

        for i, val in enumerate(coord):
            if val < ranges[i][0]:
                ranges[i][0] = val
            if val > ranges[i][1]:
                ranges[i][1] = val

    return ranges


def generate_kinds(atomic_symbols):
    # Generates the &KIND block for a symbol for cp2k
    template = '&KIND {{symbol}}\n'
    template += '      BASIS_SET DZVP-GTH-PADE\n'
    template += '      POTENTIAL GTH-PADE-q{{num_valence}}\n'
    template += '    &END KIND\n'
    template = jinja2.Template(template)

    kinds = ''
    for symbol in set(atomic_symbols):
        context = {
            'symbol': symbol.upper(),
            'num_valence': str(element(symbol).nvalence())
        }
        kinds += template.render(**context) + '\n'

    return kinds


def generate_cell(lengths):
    # Generates the &CELL block for an orthorhombic cell for cp2k
    template = '&CELL\n'
    template += '      A     {{a}}    0.000000000    0.000000000\n'
    template += '      B     0.000000000    {{b}}    0.000000000\n'
    template += '      C     0.000000000    0.000000000    {{c}}\n'
    template += '    &END CELL\n'

    context = {
        'a': '%2.9f' % lengths[0],
        'b': '%2.9f' % lengths[1],
        'c': '%2.9f' % lengths[2]
    }

    template = jinja2.Template(template)
    return template.render(**context)


def generate_coords(atomic_symbol, coords):
    cp2k_coords = '&COORD\n'
    # Generates the &COORD block for cp2k
    for symbol, coord in zip(atomic_symbol, coords):
        cp2k_coords += '      ' + symbol.upper() + '    '
        cp2k_coords += '%2.9f    %2.9f    %2.9f' % (coord[0], coord[1],
                                                    coord[2])
        cp2k_coords += '\n'

    cp2k_coords += '    &END COORD\n'

    return cp2k_coords
